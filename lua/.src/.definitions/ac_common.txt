ac.debug(key: string, value: string)
ac.log(value: string)
ac.warn(value: string)
ac.error(value: string)
ac.dirname(): string
ac.getPatchVersion(): string
ac.getPatchVersionCode(): number
ac.getFolder(f: ac.FolderId): string
ac.getTrackId(): string
ac.getTrackLayout(): string
ac.getCameraPosition(): vec3
ac.getCameraUp(): vec3
ac.getCameraSide(): vec3
ac.getCameraForward(): vec3
ac.getCameraDirection(): vec3
ac.getCameraFOV(): number
ac.getCameraPositionTo(r: vec3)
ac.getCameraUpTo(r: vec3)
ac.getCameraSideTo(r: vec3)
ac.getCameraForwardTo(r: vec3)
ac.getCameraDirectionTo(r: vec3)
ac.getSunAngle(): number
ac.getSunPitchAngle(): number
ac.getSunHeadingAngle(): number
ac.getSoundSpeedMs(): number
ac.isInteriorView(): boolean
ac.isInReplayMode(): boolean
ac.getAudioVolume(key: string): number
ac.getCarSpeedKmh(carIndex: number): number
ac.getGroundYApproximation(): number
ac.getDeltaT(): number
ac.getGameDeltaT(): number
ac.getConditionsTimeScale(): number
ac.getWindVelocity(): vec3
ac.getWindVelocityTo(r: vec3)
ac.readDataFile(value: string): string
ac.isWeatherFxActive(): boolean
ac.getTrackCoordinatesDeg(): vec2
ac.getTrackTimezoneBaseDst(): vec2
ac.hasTrackSpline(): boolean
ac.worldCoordinateToTrackProgress(v: vec3): number
ac.trackProgressToWorldCoordinate(v: number): vec3
ac.trackProgressToWorldCoordinateTo(v: number, r: vec3)
ac.worldCoordinateToTrack(v: vec3): vec3
ac.trackCoordinateToWorld(v: vec3): vec3
ac.setSystemMessage(msg: string, description: string)
ac.loadSoundbank(soundbank: string, guids: string): boolean
ac.isJoystickButtonPressed(joystick: number, button: number): boolean
ac.getJoystickAxisValue(joystick: number, axis: number): number
ac.isJoystickAxisValue(joystick: number, axis: number): number
ac.getJoystickDpadValue(joystick: number, dpad: number): number
ac.isJoystickDpadValue(joystick: number, dpad: number): number
ac.uiBeginToolWindow(windowId: string, pos: vec2, size: vec2)
ac.uiEndToolWindow()
ac.uiBeginTransparentWindow(windowId: string, pos: vec2, size: vec2)
ac.uiEndTransparentWindow()
ac.uiText(text: string)
ac.uiTextAligned(text: string, alignment: vec2, size: vec2 = vec2())
ac.uiTextWrapped(text: string)
ac.uiTextColored(text: string, color: rgbm)
ac.uiIcon24(iconId: string, size: vec2, tintCol: rgbm = rgbm(1, 1, 1, 1))
ac.uiIcon32(iconId: string, size: vec2, tintCol: rgbm = rgbm(1, 1, 1, 1))
ac.uiIcon64(iconId: string, size: vec2, tintCol: rgbm = rgbm(1, 1, 1, 1))
ac.uiGetCursor(): vec2
ac.uiSetCursor(v: vec2)
ac.uiGetCursorX(): number
ac.uiSetCursorX(v: number)
ac.uiGetCursorY(): number
ac.uiSetCursorY(v: number)
ac.uiOffsetCursorX(v: number)
ac.uiOffsetCursorY(v: number)
ac.uiSameLine(offsetFrom_start: number = 0, spacing: number = -1)
ac.uiDrawImage(filename: string, p1: vec2, p2: vec2, color: rgbm = rgbm(1, 1, 1, 1), uv1: vec2 = vec2(), uv2: vec2 = vec2(1, 1), keepAspect_ratio: boolean = false)
ac.uiDrawImageQuad(filename: string, p1: vec2, p2: vec2, p3: vec2, p4: vec2, color: rgbm = rgbm(1, 1, 1, 1), uv1: vec2 = vec2(), uv2: vec2 = vec2(1, 0), uv3: vec2 = vec2(1, 1), uv4: vec2 = vec2(0, 1))
ac.uiDrawQuadFilled(p1: vec2, p2: vec2, p3: vec2, p4: vec2, color: rgbm = rgbm(1, 1, 1, 1))
ac.uiDrawQuad(p1: vec2, p2: vec2, p3: vec2, p4: vec2, color: rgbm = rgbm(1, 1, 1, 1))
ac.uiSetShadingOffset(texBrightness: number = 1, texOffset: number = 0, alphaMult: number = 1, alphaOffset: number = 0)
ac.uiBeginTextureShade(filename: string)
ac.uiEndTextureShade(p1: vec2, p2: vec2, uv1: vec2 = vec2(), uv2: vec2 = vec2(1, 1), clamp: boolean = true)
ac.uiBeginGradientShade()
ac.uiEndGradientShade(p1: vec2, p2: vec2, col1: rgbm = rgbm(1, 1, 1, 1), col2: rgbm = rgbm(1, 1, 1, 1))
ac.uiPushClipRect(p1: vec2, p2: vec2, intersectWith_existing: boolean = true)
ac.uiPopClipRect()
ac.uiDrawRect(p1: vec2, p2: vec2, color: rgbm, rounding: number = 0, roundingFlags: number = 15, thickness: number = 1)
ac.uiDrawRectFilled(p1: vec2, p2: vec2, color: rgbm, rounding: number = 0, roundingFlags: number = 15)
ac.uiDrawLine(p1: vec2, p2: vec2, color: rgbm, thickness: number = 1)
ac.uiDrawCircle(p1: vec2, radius: number, color: rgbm, numSegments: number = 12, thickness: number = 1)
ac.uiDrawCircleFilled(p1: vec2, radius: number, color: rgbm, numSegments: number = 12)
ac.uiDrawEllipseFilled(p1: vec2, radius: vec2, color: rgbm, numSegments: number = 12)
ac.uiBeginTextureSaturationAdjustment()
ac.uiEndTextureSaturationAdjustment(value: number)
ac.uiBeginOutline()
ac.uiEndOutline(color: rgbm)
ac.uiBeginRotation()
ac.uiEndRotation(deg: number)
ac.uiBeginScale()
ac.uiEndScale(scale: vec2)
ac.uiPopStyleVar(count: number = 1)
ac.uiPushStyleColor(varId: number, value: rgbm)
ac.uiPopStyleColor(count: number = 1)
ac.uiPushFont(fontType: number)
ac.uiPopFont()
ac.uiRectHovered(p1: vec2, p2: vec2): boolean
ac.uiMouseClicked(button: number = 0): boolean
ac.uiMouseDown(button: number = 0): boolean
ac.uiMouseDoubleClicked(button: number = 0): boolean
ac.uiMousePos(): vec2
ac.uiACText(text: string, letter: vec2, marginOffset: number = 0, color: rgbm = rgbm(1, 1, 1, 1))
ac.uiPushACFont(name: string)
ac.uiPopACFont()
ac.getSimState(): stateSim
ac.getUiState(): stateUi
ac.getCarState(index: number): stateCar

struct stateWheel {
	float tyreRadius;
	float tyreWidth;
	float rimRadius;
	float tyreDirty;
	float tyreWear;
	float tyrePressure;
	float tyreTemperature;
	float discTemperature;
	float angularSpeed;
	float loadK;
	float slip;
	float slipAngle;
	float slipRatio;
	float ndSlip;
	float suspensionDamage;
	float suspensionTravel;
	vec3 contactNormal;
	vec3 contactPoint;
	vec3 pos;
	vec3 look;
	vec3 up;
	vec3 outside;
	bool isBlown;
}

struct stateCar {
	float mass;
	float maxFuel;
	float exposureOutside;
	float exposureInside;
	float shakeMultiplier;
	vec3 aabbCenter;
	vec3 aabbSize;
	vec3 pos;
	vec3 velocity;
	vec3 acceleration;
	vec3 angularVelocity;
	vec3 localAngularVelocity;
	vec3 up;
	vec3 look;
	vec3 side;
	float gas;
	float brake;
	float clutch;
	float steer;
	float handbrake;
	int gear;
	float fuel;
	float rpm;
	float rpmLimiter;
	float speedKmh;
	float turboBoost;
	float finalForceFeedback;
	float drivetrainSpeed;
	float waterTemperature;
	float cgHeight;
	int wheelsOutside;
	float engineLifeLeft;
	float damage[5];
	float gearboxDamage;
	int nodeIndex;
	int visibleIndex;
	float distanceToCamera;
	float splinePosition;
	float collisionDepth;
	int collidedWith; // 0 for track, non-zero for cars
	state_wheel wheels[4];
	bool isAiControlled;
	bool isInPitlane;
	bool isRetired;
	bool gearGrinding;
	bool headlightsActive;
	bool brakeLightsActive;
	bool flashingLightsActive;
	bool hornActive;
	bool focused;
	bool focusedOnInterior;
	bool hazardLights;
	bool turningLeftLights;
	bool turningRightLights;
	bool turningLeftOnly;
	bool turningRightOnly;
	bool lowBeams;
	bool extraA;
	bool extraB;
	bool extraC;
	bool extraD;
	float distanceDrivenTotalKm;
	float distanceDrivenSessionKm;
	float poweredWheelsSpeed;
	float batteryVoltage;
	float oilPressure;
	float oilTemperature;
	float exhaustTemperature;
	int wiperMode;
	float wiperProgress;
	float bodyWetness;
	float compass;
	int lapTimeMs;
	int bestLapTimeMs;
	int previousLapTimeMs;
	int lapCount;
	int racePosition;
	int estimatedLapTimeMs;
	float performanceMeter;
	float performanceMeterSpeedDifferenceMs;
	int sessionLapCount;
	int compoundIndex;
	bool physicsAvailable;
	bool speedLimiterInAction;
	bool absInAction;
	bool tractionControlInAction;
	int tractionControlMode; // 0 for disabled TC
	int absMode; // 0 for disabled ABS
	float speedLimiter;
	float differentialPreload;
	float awdFrontShare;
	float drivetrainTorque;
	float drivetrainPower;
	float brakeBias;
	float turboBoosts[8];
	float turboWastegates[8];
	float tractionControl2;
	float fuelMap;
}

struct stateSim {
	vec3 cameraPosition;
	vec3 cameraLook;
	vec3 cameraUp;
	int carsCount;
	int focusedCar;
	float dt;
	bool isReplayActive;
	bool isFocusedOnInterior;
	bool isSessionStarted;
	float ambientTemperature;
	float roadTemperature;
	float windSpeedKmh;
	vec2 windVelocityKmh;
	float windDirectionDeg;
	float rainIntensity;
	float rainWetness;
	float rainWater;
	float timeTotalSeconds;
	int timeHours;
	int timeMinutes;
	int timeSeconds;
	int raceFlagType;
	int raceSessionType;
	float timeToSessionStart;
	float sessionTimeLeft;
	int currentSessionIndex;
	int sessionsCoint;
	float trackLengthM;
}

struct stateUi {
	vec2 windowSize;
	vec2 mousePos;
	float dt;
	bool isMouseLeftKeyClicked;
	bool isMouseRightKeyClicked;
}